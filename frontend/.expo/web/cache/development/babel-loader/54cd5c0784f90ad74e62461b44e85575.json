{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { UnavailabilityError } from 'expo-modules-core';\nimport { CryptoDigestAlgorithm, CryptoEncoding } from \"./Crypto.types\";\nimport ExpoCrypto from \"./ExpoCrypto\";\nexport * from \"./Crypto.types\";\nvar CryptoError = function (_TypeError) {\n  _inherits(CryptoError, _TypeError);\n  var _super = _createSuper(CryptoError);\n  function CryptoError(message) {\n    var _this;\n    _classCallCheck(this, CryptoError);\n    _this = _super.call(this, \"expo-crypto: \" + message);\n    _this.code = 'ERR_CRYPTO';\n    return _this;\n  }\n  return _createClass(CryptoError);\n}(_wrapNativeSuper(TypeError));\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\" + Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.'));\n  }\n}\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(\"Invalid data provided. Expected a string.\");\n  }\n}\nfunction assertEncoding(encoding) {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\" + Object.keys(CryptoEncoding).join(', CryptoEncoding.'));\n  }\n}\nexport function digestStringAsync(_x, _x2) {\n  return _digestStringAsync.apply(this, arguments);\n}\nfunction _digestStringAsync() {\n  _digestStringAsync = _asyncToGenerator(function* (algorithm, data) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      encoding: CryptoEncoding.HEX\n    };\n    if (!ExpoCrypto.digestStringAsync) {\n      throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n    }\n    assertAlgorithm(algorithm);\n    assertData(data);\n    assertEncoding(options.encoding);\n    return yield ExpoCrypto.digestStringAsync(algorithm, data, options);\n  });\n  return _digestStringAsync.apply(this, arguments);\n}","map":{"version":3,"names":["UnavailabilityError","CryptoDigestAlgorithm","CryptoEncoding","ExpoCrypto","CryptoError","_TypeError","_inherits","_super","_createSuper","message","_this","_classCallCheck","call","code","_createClass","_wrapNativeSuper","TypeError","assertAlgorithm","algorithm","Object","values","includes","keys","join","assertData","data","assertEncoding","encoding","digestStringAsync","_x","_x2","_digestStringAsync","apply","arguments","_asyncToGenerator","options","length","undefined","HEX"],"sources":["../src/Crypto.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * The `digestStringAsync()` method of `Crypto` generates a digest of the supplied `data` string with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * You can specify the returned string format as one of `CryptoEncoding`. By default, the resolved value will be formatted as a `HEX` string.\n * On web, this method can only be called from a secure origin (https) otherwise an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @param options Format of the digest string. Defaults to: `CryptoDigestOptions.HEX`.\n * @return Return a Promise which fulfills with a value representing the hashed input.\n *\n * @example\n * ```ts\n * const digest = await Crypto.digestStringAsync(\n *   Crypto.CryptoDigestAlgorithm.SHA512,\n *   'ðŸ¥“ Easy to Digest! ðŸ’™'\n * );\n * ```\n */\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"],"mappings":";;;;;;;;;AAAA,SAASA,mBAAmB,QAAQ,mBAAmB;AAEvD,SAASC,qBAAqB,EAAEC,cAAc;AAC9C,OAAOC,UAAU;AAEjB;AAA+B,IAEzBC,WAAY,aAAAC,UAAA;EAAAC,SAAA,CAAAF,WAAA,EAAAC,UAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,WAAA;EAGhB,SAAAA,YAAYK,OAAe;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,WAAA;IACzBM,KAAA,GAAAH,MAAA,CAAAK,IAAA,yBAAsBH,OAAO;IAAIC,KAAA,CAHnCG,IAAI,GAAG,YAAY;IAAA,OAAAH,KAAA;EAInB;EAAC,OAAAI,YAAA,CAAAV,WAAA;AAAA,EAAAW,gBAAA,CALuBC,SAAS;AAQnC,SAASC,eAAeA,CAACC,SAAgC;EACvD,IAAI,CAACC,MAAM,CAACC,MAAM,CAACnB,qBAAqB,CAAC,CAACoB,QAAQ,CAACH,SAAS,CAAC,EAAE;IAC7D,MAAM,IAAId,WAAW,yEACmDe,MAAM,CAACG,IAAI,CAC/ErB,qBAAqB,CACtB,CAACsB,IAAI,CAAC,mCAAmC,CAAC,CAC5C;;AAEL;AAEA,SAASC,UAAUA,CAACC,IAAY;EAC9B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAM,IAAIrB,WAAW,6CAA6C;;AAEtE;AAEA,SAASsB,cAAcA,CAACC,QAAwB;EAC9C,IAAI,CAACR,MAAM,CAACC,MAAM,CAAClB,cAAc,CAAC,CAACmB,QAAQ,CAACM,QAAQ,CAAC,EAAE;IACrD,MAAM,IAAIvB,WAAW,iEAC2Ce,MAAM,CAACG,IAAI,CACvEpB,cAAc,CACf,CAACqB,IAAI,CAAC,mBAAmB,CAAC,CAC5B;;AAEL;AAuBA,gBAAsBK,iBAAiBA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AActC,SAAAF,mBAAA;EAAAA,kBAAA,GAAAG,iBAAA,CAdM,WACLhB,SAAgC,EAChCO,IAAY,EACmD;IAAA,IAA/DU,OAAA,GAAAF,SAAA,CAAAG,MAAA,QAAAH,SAAA,QAAAI,SAAA,GAAAJ,SAAA,MAA+B;MAAEN,QAAQ,EAAEzB,cAAc,CAACoC;IAAG,CAAE;IAE/D,IAAI,CAACnC,UAAU,CAACyB,iBAAiB,EAAE;MACjC,MAAM,IAAI5B,mBAAmB,CAAC,aAAa,EAAE,mBAAmB,CAAC;;IAGnEiB,eAAe,CAACC,SAAS,CAAC;IAC1BM,UAAU,CAACC,IAAI,CAAC;IAChBC,cAAc,CAACS,OAAO,CAACR,QAAQ,CAAC;IAEhC,aAAaxB,UAAU,CAACyB,iBAAiB,CAACV,SAAS,EAAEO,IAAI,EAAEU,OAAO,CAAC;EACrE,CAAC;EAAA,OAAAJ,kBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module"}